package dbaas

import (
	// These are Go's standard libraries for handling I/O, JSON, formatting, etc.
	"bytes"
	"encoding/json"
	"fmt"
	// These are specific libraries from the Terraform SDK and a YAML library.
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.in/yaml.v3"
	"regexp"
	"strings"
	"time"
)

// --- Global Variables and Constants ---

// `var` blocks are used to declare package-level variables. These are accessible by any function in this file.
var (
	// `regexp.MustCompile` pre-compiles a regular expression for efficiency. This is much faster
	// than compiling the regex every time it's used.
	// This regex is designed to find and extract the "Logs:" portion from a larger log string.
	friendlyOutputRegexp = regexp.MustCompile(`(?m)^.*?(Logs: .*)$`)
	// This regex is used to find escaped newline characters (`\n`) and replace them with real newlines
	// to make log output more readable.
	escapeCRNL = regexp.MustCompile(`(?m)(\s)*\\n`)
)

// This is a map that holds the default values for the `metadata` block in our resource.
// It provides a single, central place to define these defaults, making them easy to manage.
var defaultMetadataAttributes = map[string]interface{}{
	"type":       "database-postgres-exploit",
	"affinity":   "all",
	"retry":      true,
	"wait_retry": 5,
	"timeout":    60,
}

// --- Helper Functions ---

// getMetadata is a safe way to get a value from the resource's metadata configuration.
// It prevents errors by providing a default value if the metadata block or the specific key isn't set.
func getMetadata(key string, d *schema.ResourceData) interface{} {
	if d == nil {
		// If the entire resource data is nil, we can only return the hardcoded default.
		return defaultMetadataAttributes[key]
	}
	// `d.Get()` retrieves the value from the Terraform state. We type-assert it to a map.
	metadata := d.Get("metadata.0").(map[string]interface{})
	if len(metadata) != 0 {
		// If the metadata block exists, return the value for the requested key.
		return metadata[key]
	} else {
		// If the metadata block is empty, fall back to the default.
		return defaultMetadataAttributes[key]
	}
}

// jsonPrettyPrint is a simple utility to format a JSON string with indentation, making it easier to read.
func jsonPrettyPrint(input []byte) string {
	var out bytes.Buffer
	err := json.Indent(&out, []byte(input), "", "  ")
	if err != nil {
		// If formatting fails, return the original string.
		return string(input)
	}
	return out.String()
}

// JsonMarshalHTML is a custom JSON marshaler.
// The key feature is `encoder.SetEscapeHTML(false)`, which prevents Go from replacing characters
// like `<`, `>`, and `&` with their unicode equivalents (e.g., `\u0026`). This is useful when the
// JSON output needs to be perfectly clean and not intended for direct embedding in HTML.
func JsonMarshalHTML(i interface{}) ([]byte, error) {
	buffer := &bytes.Buffer{}
	encoder := json.NewEncoder(buffer)
	encoder.SetEscapeHTML(false)
	err := encoder.Encode(i)
	return bytes.TrimRight(buffer.Bytes(), "\n"), err
}

// handleHTTPError is a placeholder for a more robust HTTP error handler.
// Its current implementation is very basic.
func handleHTTPError(err error, body string, url, baseMsg string) error {
	if err != nil {
		return fmt.Errorf("%s %v", baseMsg, err)
	}
	var result interface{}
	// Check if the response body is valid JSON.
	if json.Valid([]byte(body)) {
		err = json.Unmarshal([]byte(body), &result)
		if err != nil {
			return fmt.Errorf("%s %v", baseMsg, err)
		}
	} else {
		// If the body isn't JSON, it indicates a problem.
		return fmt.Errorf("%s Empty/Invalid json response from %s", baseMsg, url)
	}
	// This function currently returns `nil` on success, but it could be expanded
	// to parse the `result` for specific error messages from the API.
	return nil
}

// --- Shared Data Structures (Structs) ---
// These structs are the blueprints for the data we expect to receive from the API.
// The `json:"..."` tags are critical: they tell Go's JSON unmarshaler how to map
// the fields from the JSON object (e.g., "taskid") to the fields in our Go struct (e.g., `TaskID`).

// JobProperties is the blueprint for the main job object returned by the API.
type JobProperties struct {
	Name        string                 `json:"name" example:"test"`
	State       string                 `json:"state" example:"finished"`
	TaskID      string                 `json:"taskid" example:"c1c6ef46-86c4-4443-a60a-94c6b7abadd5"`
	User        string                 `json:"user" example:"test"`
	Tenant      string                 `json:"tenant" example:"test"`
	Type        string                 `json:"type" example:"test"`
	CurrentData string                 `json:"current_data"`
	DesiredData string                 `json:"desired_data"`
	BeginTime   time.Time              `json:"begintime"`
	EndTime     time.Time              `json:"endtime"`
	Error       string                 `json:"error,omitempty"`
	Output      []TaskWorkerProperties `json:"output,omitempty"`
}

// TaskWorkerProperties is the blueprint for an individual worker's output within a job.
// A job can have multiple tasks, and this struct defines a single one.
type TaskWorkerProperties struct {
	Worker  string                 `json:"worker" binding:"required"`
	State   string                 `json:"state" binding:"required"`
	Data    string                 `json:"data" example:"processed!"`
	Logs    string                 `json:"logs" example:"blabla"`
	EndTime time.Time              `json:"endtime"`
	Retries []TaskWorkerProperties `json:"retries,omitempty"` // A task can have its own retries, creating a nested structure.
}

// JobOutput is a simplified struct used to populate the resource's "output" attribute in the Terraform state.
type JobOutput struct {
	Worker string `json:"worker" mapstructure:"worker"`
	Data   string `json:"data" mapstructure:"data"`
}

// --- API Helper Functions ---
// These functions wrap the generic `send_request` method from the API client,
// making calls to specific API endpoints cleaner and less repetitive.

// getJob fetches the full details of a specific job.
func getJob(client *api_client, jobType, jobName string) (JobProperties, error) {
	var job JobProperties
	var headers map[string]string
	// Construct the specific API path for getting job details.
	path := fmt.Sprintf("/jobs/%s/%s/details", jobType, jobName)
	// Make the API call.
	jobraw, err := client.send_request("GET", path, "", headers)
	if err != nil {
		return job, err
	}
	// Unmarshal the raw JSON string response into our `job` struct.
	json.Unmarshal([]byte(jobraw), &job)

	return job, nil
}

// retryJob sends a request to the API to retry a failed job.
func retryJob(client *api_client, jobType, jobName string) (JobProperties, error) {
	var job JobProperties
	var headers map[string]string
	path := fmt.Sprintf("/jobs/%s/%s/retry", jobType, jobName)
	jobraw, err := client.send_request("POST", path, "", headers)
	if err != nil {
		return job, err
	}
	json.Unmarshal([]byte(jobraw), &job)

	return job, nil
}

// SliceFind is a generic utility function. It takes a slice of strings and a value,
// and returns true if the value is found in the slice.
func SliceFind(slice []string, val string) bool {
	for _, item := range slice {
		if item == val {
			return true
		}
	}
	return false
}

// --- User-Friendly Error Formatting ---
// These structs are blueprints for creating a clean, structured error message in YAML format.
// This is a high-quality feature that makes debugging failed Terraform runs much easier for the end user.
type FriendlyErrorOutput struct {
	Name    string          `yaml:"name"`
	State   string          `yaml:"state"`
	TaskID  string          `yaml:"taskid"`
	Type    string          `yaml:"type"`
	Errors  []FriendlyError `yaml:"errors"`
	Retries []FriendlyError `yaml:"retries,omitempty"`
}

type FriendlyError struct {
	Workers []string `yaml:"workers"`
	Message string   `yaml:"message"`
}

// friendlyYAMLError is a high-level error formatting function. It takes a raw JobProperties
// object (which contains potentially messy and repetitive error logs from multiple workers) and
// translates it into a clean, summarized, and human-readable YAML report. This significantly
// improves the user's ability to debug failed Terraform runs.
func friendlyYAMLError(job JobProperties) error {
	// --- PHASE 1: INITIALIZE THE REPORT BLUEPRINT ---
	// We start by creating an empty instance of our final report structure.
	// Think of this as creating a blank report template to be filled out.
	var errorOutput FriendlyErrorOutput
	// Populate the "header" of our report with the basic job information.
	// This gives the user immediate context about which job failed.
	errorOutput.Name = job.Name
	errorOutput.State = job.State
	errorOutput.TaskID = job.TaskID
	errorOutput.Type = job.Type

	// --- PHASE 2: AGGREGATE AND GROUP WORKER ERRORS ---
	// This is the most complex part of the function. The goal is to loop through all the raw
	// task outputs from the job and group them intelligently.

	// We create two temporary "bins" to sort our errors into. One for the initial failures
	// and one for the failures that occurred during a retry attempt.
	// We use `[]map[string]interface{}` because it's a flexible structure for this temporary grouping.
	var appendedWorkerOutputs []map[string]interface{}
	var appendedWorkerRetries []map[string]interface{}
	// We examine each worker's output from the job, one by one.
	for _, workerOutput := range job.Output {
		var appended bool
		var appendedRetry bool
		// OPTIMIZATION: If a worker succeeded on its first try, we don't care about it.
		// `continue` tells the loop to immediately skip to the next workerOutput.
		if workerOutput.State == "finished" {
			continue
		}
		// Before processing the primary task failure, we check if any of its *retries* were successful.
		successRetry := false
		// ignore the worker if it is successfull in retries
		for _, workerRetry := range workerOutput.Retries {
			// If any retry for this worker succeeded, the worker as a whole is considered successful.
			if workerRetry.State == "finished" {
				successRetry = true
				break // `break` exits the inner "retries" loop immediately.
			} else {
				// --- This is the grouping logic for FAILED RETRIES ---
				// We check if we have already seen this *exact same error message* from another failed retry.
				for _, appendedWorkerRetry := range appendedWorkerRetries {
					if appendedWorkerRetry["logs"] == workerRetry.Logs {
						// If we've seen this error message before, we just add the current worker's name
						// to the list of workers for that error, avoiding duplicates.
						if !SliceFind(appendedWorkerRetry["workers"].([]string), workerRetry.Worker) {
							appendedWorkerRetry["workers"] = append(appendedWorkerRetry["workers"].([]string), workerRetry.Worker)
						}
						appendedRetry = true
					}
				}

				// This retry was grouped; move to the next one.
				if appendedRetry {
					continue
				}

				// If we reach here, this is a new, unique error message for a retry.
				// We create a new "bin" for it.
				retriesToAppend := make(map[string]interface{})
				retriesToAppend["workers"] = []string{workerRetry.Worker}

				retriesToAppend["logs"] = workerRetry.Logs
				appendedWorkerRetries = append(appendedWorkerRetries, retriesToAppend)
			}
		}
		// If a retry was successful, the entire worker is considered a success. Skip it.
		if successRetry {
			continue
		}

		// --- This is the grouping logic for the INITIAL FAILED TASKS ---
		// This logic mirrors the retry logic above. We check if we've seen this error message before.
		for _, appendedWorkerOutput := range appendedWorkerOutputs {
			if appendedWorkerOutput["logs"] == workerOutput.Logs {
				// If yes, just add this worker's name to the existing group.
				appendedWorkerOutput["workers"] = append(appendedWorkerOutput["workers"].([]string), workerOutput.Worker)
				appended = true
			}
		}
		// This worker was grouped; move to the next one.
		if appended {
			continue
		}
		// If we reach here, this is a new, unique error message for an initial task failure.
		// We create a new "bin" for it in our `appendedWorkerOutputs` slice.
		outputToAppend := make(map[string]interface{})
		outputToAppend["workers"] = []string{workerOutput.Worker}
		outputToAppend["logs"] = workerOutput.Logs
		appendedWorkerOutputs = append(appendedWorkerOutputs, outputToAppend)
	}
	// --- PHASE 3: FORMAT THE GROUPED DATA INTO THE FINAL REPORT ---
	// Now that we have our errors neatly grouped in our temporary "bins", we format them
	// for the final report.

	// Process the initial failed job outputs.

	// failed job outputs
	for _, appendedWorkerOutput := range appendedWorkerOutputs {
		var ferror FriendlyError // Create an empty, friendly error struct.
		ferror.Workers = appendedWorkerOutput["workers"].([]string)

		// This section cleans up the raw log string to make it more readable.
		// It uses the pre-compiled regular expressions from the top of the file.
		workerLog := friendlyOutputRegexp.ReplaceAllString(appendedWorkerOutput["logs"].(string), "$1") // Extract just the "Logs: ..." part.
		workerLog = strings.Replace(workerLog, " Error:", "\nError:", -1)                               // Add a newline before "Error:".
		workerLog = escapeCRNL.ReplaceAllString(workerLog, "\n")                                        // Replace `\n` with actual newlines.
		ferror.Message = workerLog
		// Add the fully formatted, friendly error to our final report's "Errors" list.
		errorOutput.Errors = append(errorOutput.Errors, ferror)
	}

	// Do the exact same formatting process for the failed retries.
	for _, appendedWorkerRetry := range appendedWorkerRetries {
		var ferror FriendlyError
		ferror.Workers = appendedWorkerRetry["workers"].([]string)

		// Apply the same cleanup logic to the retry logs.
		workerLog := friendlyOutputRegexp.ReplaceAllString(appendedWorkerRetry["logs"].(string), "$1")
		workerLog = strings.Replace(workerLog, " Error:", "\nError:", -1)
		workerLog = escapeCRNL.ReplaceAllString(workerLog, "\n")
		ferror.Message = workerLog
		// Add the formatted error to our final report's "Retries" list.
		errorOutput.Retries = append(errorOutput.Retries, ferror)
	}
	// --- PHASE 4: GENERATE AND RETURN THE FINAL ERROR ---
	// Convert our final, structured Go object (`errorOutput`) into a YAML formatted string.
	yamlStr, err := yaml.Marshal(errorOutput)
	if err != nil {
		// If, for some reason, the YAML conversion fails, we return a fallback error.
		return fmt.Errorf("Unable to yaml marshal: %v\n\nJob error is: %v", err, errorOutput)
	}
	// Finally, wrap our beautiful YAML report inside a standard Go error object and return it.
	// This is what Terraform will ultimately display to the user.
	return fmt.Errorf(". Task details:\n\n%s", yamlStr)

}

func buildSuccessOutput(job JobProperties) map[string]interface{} {
	return map[string]interface{}{
		"name":   job.Name,
		"state":  job.State,
		"taskid": job.TaskID,
		"type":   job.Type,
	}
}
