package dbaas

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// Provider is the primary entry point for the Terraform provider. Terraform Core calls this function
// to get the provider's "blueprint". This blueprint includes the provider-level configuration schema,
// a list of all resources and data sources it supports, and the function to configure it.
//
// The return type is `*schema.Provider`, a pointer to a struct that holds all this information.
// Using a pointer is a Go convention for efficiency, avoiding copying the large provider object.
func Provider() *schema.Provider {
	return &schema.Provider{
		// --- PROVIDER-LEVEL CONFIGURATION SCHEMA ---
		// The `Schema` field defines the configuration arguments that users can set within the `provider "dbaas" { ... }`
		// block in their HCL files. This is where you define how users provide connection details like API endpoints and credentials.
		Schema: map[string]*schema.Schema{
			// "uri" is the base URL for the DBaaS API.
			"uri": {
				Type:     schema.TypeString,
				Optional: true, // Optional means the user is not required to set it directly in the provider block.
				// `DefaultFunc` is a powerful feature that provides a default value.
				// `schema.EnvDefaultFunc` is a standard helper that tells Terraform to read the value
				// from an environment variable (`DBAAS_URI`) if it's not set in the HCL.
				// This is a best practice for flexibility and security.
				DefaultFunc: schema.EnvDefaultFunc("DBAAS_URI", nil),
				Description: "moldapi base URL",
			},
			// "token" is the Bearer token for API authentication.
			"token": {
				Type:        schema.TypeString,
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("DBAAS_TOKEN", nil),
				Description: "Token for Bearer auth to the API.",
			},
			// "username" for HTTP Basic Authentication.
			"username": {
				Type:        schema.TypeString,
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("DBAAS_USERNAME", nil),
				Description: "Username for BASIC auth to the API.",
			},
			// "password" for HTTP Basic Authentication.
			"password": {
				Type:        schema.TypeString,
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("DBAAS_PASSWORD", nil),
				Description: "Password for BASIC auth to the API.",
			},
			// "insecure" allows disabling TLS certificate checks.
			"insecure": {
				Type:        schema.TypeBool,
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("DBAAS_INSECURE", nil),
				Description: "Disables TLS verification if using HTTPS.",
			},
			// "timeout" for API requests.
			"timeout": {
				Type:        schema.TypeInt,
				Optional:    true,
				Default:     60,
				Description: "Timeout in seconds for requests.",
			},
			// "debug" enables verbose request/response logging.
			"debug": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     false,
				Description: "Enable debug mode to trace requests.",
			},
		},
		// --- RESOURCE AND DATA SOURCE MAPPING ---
		// `ResourcesMap` is the provider's catalog of manageable resources. It's a map where the key
		// is the resource name used in HCL (e.g., "dbaas-postgres-exploit_pg_exploit") and the value
		// is the result of the function that defines that resource's schema and lifecycle.
		ResourcesMap: map[string]*schema.Resource{
			"dbaas-postgres-exploit_pg_exploit": resourcePgExploit(),
		},
		// `DataSourcesMap` is the catalog of data sources (read-only resources). It's empty here,
		// meaning this provider does not currently implement any `data` blocks.
		DataSourcesMap: map[string]*schema.Resource{},
		// --- INITIALIZATION HOOK ---
		// `ConfigureFunc` specifies the function that Terraform must run to initialize the provider.
		// This function is responsible for taking the user's configuration and creating a client
		// or any other object that the resources will need to interact with the target API.
		ConfigureFunc: configureProvider,
	}
}

// configureProvider is the initialization function for the provider.
// It is called once by Terraform at the beginning of a run (`plan`, `apply`, `destroy`).
// Its job is to take the user-provided configuration, create and configure an API client,
// and return that client for use by all other resource functions.
//
// `d *schema.ResourceData` contains the values the user set in the `provider` block.
// It returns an `interface{}` and an `error`. The `interface{}` is the configured client object.
func configureProvider(d *schema.ResourceData) (interface{}, error) {
	// Create an empty map for any potential default headers.
	headers := make(map[string]string)
	// Populate an options struct (`apiClientOpt`) with the values read from the provider configuration (`d`).
	// This makes passing the configuration to the client's constructor cleaner.
	// `d.Get()` is used to retrieve each configured value. We must type-assert the result (e.g., `.(string)`).
	opt := &apiClientOpt{
		token:    d.Get("token").(string),
		username: d.Get("username").(string),
		password: d.Get("password").(string),
		insecure: d.Get("insecure").(bool),
		uri:      d.Get("uri").(string),
		headers:  headers,
		timeout:  d.Get("timeout").(int),
		debug:    d.Get("debug").(bool),
	}
	// Call the constructor for our API client, passing the configured options.
	client, err := NewAPIClient(opt)
	// Return the newly created client and any error that may have occurred during its creation.
	// This returned `client` object will be passed as the `meta` argument to all of the resource
	// Create, Read, Update, and Delete functions. This is how they get access to the API.
	return client, err

}
