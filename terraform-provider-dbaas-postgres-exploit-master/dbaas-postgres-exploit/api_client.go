package dbaas

import (
	"bytes"
	"crypto/tls"
	"crypto/x509"
	"errors"
	"fmt"
	"io/ioutil"
	//	"log"
	"net/http"
	"net/http/httputil"
	"strings"
	"time"
)

// apiClientOpt is a struct that acts as a blueprint for the options used to create our API client.
// It's a clean way to pass all the possible configuration settings into the `NewAPIClient` constructor function.
// It's like a temporary "options form" that gets thrown away after the client is built.
type apiClientOpt struct {
	uri      string            // The base URL of the MOLDAPI.
	cert     string            // A special ID card (client certificate) for the client.
	key      string            // The secret key that goes with the ID card.
	ca       string            // A list of trusted authorities to verify the server's ID card.
	token    string            // The Bearer token for authentication.
	insecure bool              // If true, disables TLS certificate verification. Use with caution.
	username string            // The username for HTTP Basic Authentication.
	password string            // The password for HTTP Basic Authentication.
	headers  map[string]string // A set of extra labels to put on every request (package).
	timeout  int               // How long to wait for a response before giving up.
	debug    bool              // Should we print out detailed logs of every action?
}

// api_client is the struct that represents the actual, living API client.
// Once created, an instance of this struct holds all the configured tools (like the http_client)
// and settings it needs to do its job of communicating with the API. This is the "Employee ID Card".
type api_client struct {
	http_client *http.Client      // The underlying Go HTTP client that will perform the requests.
	uri         string            // The base URI of the MOLDAPI.
	cert        string            // The client certificate content.
	key         string            // The client private key content.
	ca          string            // The CA certificate content.
	insecure    bool              // The configured insecure setting.
	token       string            // The configured Bearer token.
	username    string            // The configured username for Basic Auth.
	password    string            // The configured password for Basic Auth.
	headers     map[string]string // The configured global headers.
	timeout     int               // The configured request timeout.
	debug       bool              // The configured debug mode setting.
}

// NewAPIClient is the constructor function for our api_client.
// It takes the apiClientOpt configuration, validates it, and returns a
// fully configured client instance ready to make API calls.
func NewAPIClient(opt *apiClientOpt) (*api_client, error) {
	// First, a critical validation. If we don't know the destination address, we can't do anything.
	if opt.uri == "" {
		return nil, errors.New("No URI defined, please set the dbaas uri.")
	}
	// Clean up the user's input to prevent common errors, like an extra "/" at the end of the URL.
	opt.uri = strings.TrimRight(opt.uri, "/")
	// --- TLS Configuration: The Security Handshake Rules ---
	// This is the rulebook for how our client should securely connect to the server.
	tlsConfig := &tls.Config{
		// This is a critical security switch. If `true`, it tells the client: "Don't bother verifying the server's
		// identity certificate." This is dangerous in production but necessary for development with self-signed certs.
		InsecureSkipVerify: opt.insecure,
	}
	// If the user provided a client certificate and key (for mutual TLS authentication)...
	if opt.cert != "" && opt.key != "" {
		var cert tls.Certificate
		var err error
		// Check if the certificate/key was provided as a raw string or as a file path.
		if strings.HasPrefix(opt.cert, "-----BEGIN") && strings.HasPrefix(opt.key, "-----BEGIN") {
			// If it's a raw string, load the key pair directly from memory.
			cert, err = tls.X509KeyPair([]byte(opt.cert), []byte(opt.key))
		} else {
			// Otherwise, assume it's a path to a file on disk and load it.
			cert, err = tls.LoadX509KeyPair(opt.cert, opt.key)
		}
		if err != nil {
			return nil, err // If we can't load the client's own identity, we must fail.
		}
		// Add our identity certificate to the rulebook.
		tlsConfig.Certificates = []tls.Certificate{cert}
	}
	// If the user provided a custom Certificate Authority (CA) to trust...
	if opt.ca != "" {
		var caCert []byte
		var err error
		// As before, check if it's a raw string or a file path.
		if strings.HasPrefix(opt.ca, "-----BEGIN") {
			caCert = []byte(opt.ca)
		} else {
			caCert, err = ioutil.ReadFile(opt.ca)
			if err != nil {
				return nil, err
			}
		}
		// Create a new pool of trusted CAs and add the user's custom CA to it.
		caCertPool := x509.NewCertPool()
		caCertPool.AppendCertsFromPEM(caCert)
		// Set this pool as the ultimate source of truth for verifying the server's identity.
		tlsConfig.RootCAs = caCertPool
	}
	// Create an HTTP "Transport". Think of this as the vehicle that will carry our requests.
	// We give it our custom security rulebook (`tlsConfig`).
	tr := &http.Transport{
		TLSClientConfig: tlsConfig,
	}
	// --- Final Assembly of the Client ---
	// Now we create the final `api_client` struct instance.
	client := &api_client{
		// Create the actual `http.Client` tool, configured with our timeout and custom transport vehicle.
		http_client: &http.Client{
			// Set the timeout for all requests made by this client.
			Timeout:   time.Second * time.Duration(opt.timeout),
			Transport: tr,
		},
		// Copy all the final, validated settings from the options to our new client's fields.
		uri:      opt.uri,
		cert:     opt.cert,
		key:      opt.key,
		ca:       opt.ca,
		insecure: opt.insecure,
		token:    opt.token,
		username: opt.username,
		password: opt.password,
		headers:  make(map[string]string), // Initialize an empty map for headers.
		timeout:  opt.timeout,
		debug:    opt.debug,
	}

	// If the user provided any global headers in the options, copy them into our client's header map.
	for k, v := range opt.headers {
		client.headers[k] = v
	}
	// Return the fully configured, ready-to-use client and `nil` for the error to indicate success.
	return client, nil
}

// send_request is a "method" of the `api_client` struct. This means it "belongs" to the client.
// You can only call this function on a client instance that has already been created (e.g., `myClient.send_request(...)`).
// Its job is to handle all the details of sending one single HTTP request.
func (client *api_client) send_request(method string, path string, data string, headers map[string]string) (string, error) {
	// Construct the full destination URL by combining the base URI with the specific request path.
	full_uri := client.uri + path
	var req *http.Request
	var err error
	// A `bytes.Buffer` is a temporary in-memory container for the request body data.
	buffer := bytes.NewBuffer([]byte(data))
	// Create a new HTTP request object.
	if data == "" {
		// Create a request with no body.
		req, err = http.NewRequest(method, full_uri, nil)
	} else {
		// Create a request with a body.
		req, err = http.NewRequest(method, full_uri, buffer)
	}
	if err != nil {
		return "", err // If we can't even build the basic request, fail.
	}

	// --- Add Authentication and Headers ---
	// If our client was configured with a bearer token, add the `Authorization` header.
	if client.token != "" {
		req.Header.Set("Authorization", "Bearer "+client.token)
	}

	// Add any global headers that were configured on the client itself.
	for n, v := range client.headers {
		req.Header.Set(n, v)
	}

	// Add any headers that were passed specifically for *this* single request.
	// These will override any global headers with the same name.
	if len(headers) > 0 {
		for n, v := range headers {
			req.Header.Set(n, v)
		}
	}

	// If the client was configured with a username and password, set up HTTP Basic Auth.
	if client.username != "" && client.password != "" {
		req.SetBasicAuth(client.username, client.password)
	}

	// --- Debugging ---
	// If the client is in debug mode, print the entire outgoing request (headers and body).
	// This is extremely useful for troubleshooting.
	if client.debug {
		reqDump, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return "", err
		}
		fmt.Printf("REQUEST:\n%s\n", string(reqDump))
	}
	// --- Execute the Request ---
	// Use the configured `http_client` to send the request over the network. This is the blocking call.
	resp, err := client.http_client.Do(req)
	if err != nil {
		return "", err // If the network request itself fails, return the error.
	}
	// If in debug mode, print the entire response received from the server.
	if client.debug {
		respDump, err := httputil.DumpResponse(resp, true)
		if err != nil {
			fmt.Printf("Error dumping response: %s\n", err)
		} else {
			fmt.Printf("RESPONSE:\n%s\n", string(respDump))
		}
	}
	// Read the entire response body into memory.
	bodyBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return "", err
	}
	// Convert the byte slice into a string for easy use.
	body := string(bodyBytes)
	// Check the HTTP status code. A success is typically in the 200-299 range.
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		// If the status code indicates an error (e.g., 404 Not Found, 500 Server Error),
		// return the body and a new error describing the problem.
		return body, errors.New(fmt.Sprintf("Code HTTP inattendu : %d - %s", resp.StatusCode, body))
	}
	// If everything was successful, return the response body and a `nil` error.
	return body, nil
}
